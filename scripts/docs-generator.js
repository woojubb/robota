/**
 * Script to generate markdown API documentation from TypeScript code using TypeDoc
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { globSync } from 'glob';
import { marked } from 'marked';

// Auto-generated warning header
const AUTO_GENERATED_WARNING = `<!-- 
 ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 This file is automatically generated by scripts/docs-generator.js
 To make changes, edit the source TypeScript files or update the generator script
-->

`;

// HTML template
const HTML_TEMPLATE = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Robota API Documentation</title>
  <meta name="description" content="Robota API Documentation">
  <link rel="stylesheet" href="/robota/style.css">
</head>
<body>
  <div id="content">
    {{CONTENT}}
  </div>
  <script>
    // Redirect to Docsify when page loads
    window.addEventListener('DOMContentLoaded', function() {
      // Remove .html extension from current path
      const currentPath = window.location.pathname;
      if (currentPath.endsWith('.html')) {
        // Redirect for history mode
        const newPath = currentPath.replace('.html', '');
        window.location.replace(newPath);
      }
    });
  </script>
</body>
</html>`;

// Directory path configuration
const ROOT_DIR = process.cwd(); // Using process.cwd() since script runs from root directory
const PACKAGES_DIR = path.join(ROOT_DIR, 'packages');
const DOCS_DIR = path.join(ROOT_DIR, 'docs');
const OUTPUT_DIR = path.join(DOCS_DIR, 'api-reference');
const APPS_DOCS_DIR = path.join(ROOT_DIR, 'apps/docs');
const TEMP_DIR = path.join(APPS_DOCS_DIR, '.temp');

// API categories
const API_CATEGORIES = [
    { name: 'Core', pattern: 'packages/core/src/**/*.ts', entryPoint: path.join(PACKAGES_DIR, 'core/src/index.ts') },
    { name: 'OpenAI', pattern: 'packages/openai/src/**/*.ts', entryPoint: path.join(PACKAGES_DIR, 'openai/src/index.ts') },
    { name: 'Anthropic', pattern: 'packages/anthropic/src/**/*.ts', entryPoint: path.join(PACKAGES_DIR, 'anthropic/src/index.ts') },
    { name: 'Google', pattern: 'packages/google/src/**/*.ts', entryPoint: path.join(PACKAGES_DIR, 'google/src/index.ts') },
    { name: 'Tools', pattern: 'packages/tools/src/**/*.ts', entryPoint: path.join(PACKAGES_DIR, 'tools/src/index.ts') },
];

// Generate API documentation main file
function generateApiIndexPage() {
    const content = `${AUTO_GENERATED_WARNING}# Robota API Reference

Complete API documentation for the Robota SDK packages. Find detailed information about classes, functions, and types for each package.

## Packages

${API_CATEGORIES.map(category => `- [${category.name}](${category.name.toLowerCase()}/)`).join('\n')}
`;

    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    const indexPath = path.resolve(OUTPUT_DIR, 'README.md');
    fs.writeFileSync(indexPath, content);
}

// Generate API documentation using TypeDoc
async function generateDocsForCategory(category) {
    const { name, pattern, entryPoint } = category;

    // Check file existence
    if (!fs.existsSync(entryPoint)) {
        console.error(`‚ö†Ô∏è Entry point does not exist: ${entryPoint}`);
        return 0;
    }

    // Find files
    const files = globSync(path.join(ROOT_DIR, pattern), {
        ignore: ['**/*.test.ts', '**/*.spec.ts', '**/node_modules/**']
    });

    if (files.length === 0) {
        console.log(`‚ö†Ô∏è No files found for ${name}`);
        return 0;
    }

    // Create category directory
    const categoryDir = path.join(OUTPUT_DIR, name.toLowerCase());
    if (!fs.existsSync(categoryDir)) {
        fs.mkdirSync(categoryDir, { recursive: true });
    }

    // Execute TypeDoc command
    try {
        // Find tsconfig.json in package path
        const packageDir = path.dirname(path.dirname(entryPoint)); // Parent directory of src
        const tsconfigPath = path.join(packageDir, 'tsconfig.json');

        if (!fs.existsSync(tsconfigPath)) {
            console.error(`‚ö†Ô∏è tsconfig.json file not found: ${tsconfigPath}`);
            return 0;
        }

        const command = `npx typedoc --options ${path.join(ROOT_DIR, 'typedoc.json')} --out ${categoryDir} --entryPoints ${entryPoint} --tsconfig ${tsconfigPath} --name "${name} API"`;

        console.log(`üîÑ Converting ${name} TypeScript to Markdown...`);
        execSync(command, { stdio: 'pipe' }); // Î°úÍ∑∏ Ïà®ÍπÄ

        // Fix file structure (modules.md -> README.md)
        fixFileStructure(categoryDir, name);

        // Add auto-generated warnings
        addAutoGeneratedWarnings(categoryDir);

        // Fix link paths
        fixDocumentLinks(categoryDir, name.toLowerCase());

        console.log(`‚úÖ ${name} API documentation converted successfully`);
        return files.length;
    } catch (error) {
        console.error(`‚ö†Ô∏è Error occurred while generating ${name} category API documentation:`, error);
        return 0;
    }
}

// Fix file structure: rename modules.md to README.md and remove incorrect README.md
function fixFileStructure(categoryDir, categoryName) {
    const modulesPath = path.join(categoryDir, 'modules.md');
    const readmePath = path.join(categoryDir, 'README.md');

    // If modules.md exists: rename modules.md to README.md
    if (fs.existsSync(modulesPath)) {
        // Remove existing README.md if it exists (TypeDoc generated project overview)
        if (fs.existsSync(readmePath)) {
            fs.unlinkSync(readmePath);
        }

        // Read modules.md content
        let content = fs.readFileSync(modulesPath, 'utf-8');

        // Fix incorrect references in content
        content = content.replace(/\[.*?\]\(\.\.\/\) \/ Exports/g, `${categoryName} API`);
        content = content.replace(/# .*? API/g, `# ${categoryName} API`);

        // Save as README.md
        fs.writeFileSync(readmePath, content);

        // Remove existing modules.md
        fs.unlinkSync(modulesPath);
    }
    // If modules.md doesn't exist: fix or create new README.md content
    else {
        let content = '';

        // Check existing README.md if it exists
        if (fs.existsSync(readmePath)) {
            content = fs.readFileSync(readmePath, 'utf-8');

            // Check if it's an incorrect README.md with project-wide description
            if (content.includes('Robota is an AI agent framework') || content.includes('Project Structure')) {
                fs.unlinkSync(readmePath);
                content = '';
            }
        }

        // Create new README.md if it doesn't exist or was incorrect
        if (!fs.existsSync(readmePath)) {
            // Check classes and interfaces directories
            const classesDir = path.join(categoryDir, 'classes');
            const interfacesDir = path.join(categoryDir, 'interfaces');

            let tableOfContents = `# ${categoryName} API

## Table of contents

`;

            // Add classes section
            if (fs.existsSync(classesDir)) {
                const classFiles = fs.readdirSync(classesDir).filter(f => f.endsWith('.md'));
                if (classFiles.length > 0) {
                    tableOfContents += `### Classes

${classFiles.map(f => `- [${f.replace('.md', '')}](classes/${f.replace('.md', '')})`).join('\n')}

`;
                }
            }

            // Add interfaces section
            if (fs.existsSync(interfacesDir)) {
                const interfaceFiles = fs.readdirSync(interfacesDir).filter(f => f.endsWith('.md'));
                if (interfaceFiles.length > 0) {
                    tableOfContents += `### Interfaces

${interfaceFiles.map(f => `- [${f.replace('.md', '')}](interfaces/${f.replace('.md', '')})`).join('\n')}

`;
                }
            }

            fs.writeFileSync(readmePath, tableOfContents);
        }
    }
}

// Add auto-generated warnings to all generated files
function addAutoGeneratedWarnings(categoryDir) {
    const mdFiles = globSync(path.join(categoryDir, '**/*.md'));

    for (const mdFile of mdFiles) {
        try {
            let content = fs.readFileSync(mdFile, 'utf-8');

            // Check if warning already exists
            if (!content.includes('AUTO-GENERATED FILE')) {
                content = AUTO_GENERATED_WARNING + content;
                fs.writeFileSync(mdFile, content);
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è Error occurred while adding warning header to ${mdFile}:`, error);
        }
    }
}

// Fix link paths in API documentation (relative paths -> absolute paths)
function fixDocumentLinks(categoryDir, categoryName) {
    // Find all markdown files in the category
    const mdFiles = globSync(path.join(categoryDir, '**/*.md'));

    for (const mdFile of mdFiles) {
        try {
            // Current file's relative path (from docs directory)
            const relativePath = path.relative(DOCS_DIR, mdFile);
            // Directory containing current file (e.g., api-reference/core/classes)
            const fileDir = path.dirname(relativePath);
            // Current file name (e.g., FunctionRegistry.md)
            const fileName = path.basename(mdFile);
            // File name without extension (e.g., FunctionRegistry)
            const fileNameWithoutExt = fileName.replace('.md', '');

            // Read file content
            let content = fs.readFileSync(mdFile, 'utf-8');

            // Handle various link patterns
            // 1. README.md -> directory index
            content = content.replace(/\]\(README\.md(#[^)]+)?\)/g, (match, section) => {
                return section ? `](../${section})` : `](../)`;
            });

            // 2. ../README.md -> parent directory index
            content = content.replace(/\]\(\.\.\/README\.md(#[^)]+)?\)/g, (match, section) => {
                return section ? `](../../${section})` : `](../../)`;
            });

            // 3. Handle relative paths (e.g., ../interfaces/XXX.md -> ../interfaces/XXX)
            content = content.replace(/\]\(([^)]+)\.md(#[^)]*)?\)/g, (match, path, anchor) => {
                return `](${path}${anchor || ''})`;
            });

            // 4. Change modules links to README
            content = content.replace(/\]\(modules\)/g, '](README)');
            content = content.replace(/\]\(\.\/modules\)/g, '](./README)');

            // Save file
            fs.writeFileSync(mdFile, content);
        } catch (error) {
            console.error(`‚ö†Ô∏è Error occurred while fixing links in ${mdFile}:`, error);
        }
    }
}

// Copy public directory files to .temp directory
function copyPublicFiles() {
    const publicDir = path.join(APPS_DOCS_DIR, 'public');
    const tempPublicDir = path.join(TEMP_DIR, 'public');

    if (!fs.existsSync(publicDir)) {
        return;
    }

    // Create temp public directory if it doesn't exist
    if (!fs.existsSync(tempPublicDir)) {
        fs.mkdirSync(tempPublicDir, { recursive: true });
    }

    // Copy all files from public to temp/public
    try {
        const files = fs.readdirSync(publicDir);
        for (const file of files) {
            const srcPath = path.join(publicDir, file);
            const destPath = path.join(tempPublicDir, file);

            if (fs.statSync(srcPath).isDirectory()) {
                // Recursively copy directories
                copyDirectoryRecursive(srcPath, destPath);
            } else {
                // Copy files
                fs.copyFileSync(srcPath, destPath);
            }
        }
    } catch (error) {
        console.error('‚ö†Ô∏è Error copying public files:', error);
    }
}

// Helper function to recursively copy directories
function copyDirectoryRecursive(src, dest) {
    if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
    }

    const files = fs.readdirSync(src);
    for (const file of files) {
        const srcPath = path.join(src, file);
        const destPath = path.join(dest, file);

        if (fs.statSync(srcPath).isDirectory()) {
            copyDirectoryRecursive(srcPath, destPath);
        } else {
            fs.copyFileSync(srcPath, destPath);
        }
    }
}

async function main() {
    console.log('üîÑ Converting TypeScript to API documentation...');

    // Copy public files first
    copyPublicFiles();

    // Generate API index page
    generateApiIndexPage();

    // Generate documentation for each category
    let totalDocs = 0;
    for (const category of API_CATEGORIES) {
        const count = await generateDocsForCategory(category);
        totalDocs += count;
    }

    console.log(`‚úÖ TypeDoc conversion completed! ${totalDocs} files processed.`);
}

// Execute main function
main().catch(error => {
    console.error('‚ùå Error occurred during API documentation generation:', error);
    process.exit(1);
}); 
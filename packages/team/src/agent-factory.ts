import { Robota, AgentFactory as CoreAgentFactory } from '@robota-sdk/agents';
import type { AgentConfig as BaseAgentConfig } from '@robota-sdk/agents';
import type { TaskAgentConfig, AgentConfig } from './types';

/**
 * Factory for creating task-specific Robota agents with template support
 * 
 * @description
 * Team-specific wrapper around the core AgentFactory that creates TaskAgent instances.
 * Provides backward compatibility while enabling template-based agent creation.
 * TaskAgent adds team-specific functionality like unique IDs and resource management.
 */
export class AgentFactory {
    private coreAgentFactory: CoreAgentFactory;
    private debug: boolean;

    /**
     * Create an AgentFactory instance
     * 
     * @param baseRobotaOptions - Base configuration options for all agents
     * @param debug - Whether to enable debug logging
     */
    constructor(baseRobotaOptions: RobotaOptions, debug = false) {
        this.coreAgentFactory = new CoreAgentFactory(baseRobotaOptions, undefined, debug);
        this.debug = debug;
    }

    /**
     * Create a TaskAgent for a specific task with optional template support
     */
    async createRobotaForTask(config: TaskAgentConfig & { agentTemplate?: string }): Promise<TaskAgent> {
        if (this.debug) {
            // Debug: Creating agent for task
        }

        // Create agent creation config for core factory
        const agentCreationConfig: AgentCreationConfig = {
            taskDescription: config.taskDescription,
            requiredTools: config.requiredTools,
            templateName: config.agentTemplate,
            agentConfig: config.agentConfig
        };

        // Use core factory to create Robota instance
        const robota = await this.coreAgentFactory.createAgent(agentCreationConfig);

        // Create team-specific agent configuration
        // Note: Since we don't have access to Robota's internal options,
        // we'll use the agent creation config and fallback to core factory data
        const agentConfig: AgentConfig = {
            provider: agentCreationConfig.agentConfig?.provider || 'unknown',
            model: agentCreationConfig.agentConfig?.model || 'unknown',
            systemPrompt: 'Generated by template or dynamic prompt',
            maxTokens: agentCreationConfig.agentConfig?.maxTokens,
            temperature: agentCreationConfig.agentConfig?.temperature,
            ...config.agentConfig
        };

        return new RobotaTaskAgent(robota, agentConfig, config.requiredTools);
    }

    /**
     * Get the core template manager for advanced template operations
     */
    getTemplateManager() {
        return this.coreAgentFactory.getTemplateManager();
    }
}

/**
 * Interface for task-specific agents
 */
export interface TaskAgent {
    /** Unique identifier for the agent */
    id: string;
    /** Configuration used for this agent */
    config: AgentConfig;
    /** Tools available to this agent */
    tools: string[];
    /** Execute a prompt and return the result */
    run(prompt: string): Promise<string>;
    /** Close/cleanup the agent */
    close(): void;
    /** Get the underlying Robota instance for accessing conversation history */
    getRobotaInstance(): Robota;
}

/**
 * Wrapper class to make Robota instance compatible with TaskAgent interface
 */
class RobotaTaskAgent implements TaskAgent {
    public readonly id: string;
    public readonly config: AgentConfig;
    public readonly tools: string[];
    private robota: Robota;

    constructor(robota: Robota, config: AgentConfig, tools: string[]) {
        this.id = `agent-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        this.config = config;
        this.tools = tools;
        this.robota = robota;
    }

    /**
     * Execute a prompt and return the result
     */
    async run(prompt: string): Promise<string> {
        const response = await this.robota.run(prompt);
        return response;
    }

    /**
     * Close and cleanup the agent
     */
    close(): void {
        // Cleanup resources if needed
        // Robota instances don't typically need explicit cleanup, but this provides the interface
    }

    /**
     * Get the underlying Robota instance for accessing conversation history
     */
    getRobotaInstance(): Robota {
        return this.robota;
    }
} 
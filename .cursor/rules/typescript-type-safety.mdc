---
description: 
globs: 
alwaysApply: false
---
# TypeScript Type Safety Rules

## üö® STRICT any/unknown Type Usage Policy

### üö´ DEFAULT: NO any/unknown Types
- **Default position**: `any` and `unknown` types are **PROHIBITED**
- **Assumption**: There is always a better, more specific type available
- **Burden of proof**: You must PROVE that no alternative exists

### ‚ö†Ô∏è MANDATORY: Exhaustive Alternative Verification
Before even considering `any`/`unknown`, you MUST systematically verify ALL alternatives:

#### 1. **Union Types** - Can you enumerate all possible types?
```typescript
// ‚ùå PROHIBITED: Using unknown without checking union types
let value: unknown;

// ‚úÖ REQUIRED: Use union when types are enumerable
let value: string | number | boolean | null | undefined;
```

#### 2. **Generic Types** - Can the function be parameterized?
```typescript
// ‚ùå PROHIBITED: Unknown for reusable functions
function process(data: unknown): unknown;

// ‚úÖ REQUIRED: Use generics for type preservation
function process<T>(data: T): T;
function processWithConstraint<T extends Record<string, any>>(data: T): T;
```

#### 3. **Intersection & Extension** - Can you build on existing types?
```typescript
// ‚ùå PROHIBITED: Unknown for extensible objects
interface Context {
  [key: string]: unknown;
}

// ‚úÖ REQUIRED: Build specific extensions
interface Context extends BaseContext {
  [key: string]: string | number | boolean | Date;
}
```

#### 4. **Conditional Types** - Can type be determined conditionally?
```typescript
// ‚ùå PROHIBITED: Unknown for dependent types
type ApiResponse = unknown;

// ‚úÖ REQUIRED: Use conditional types
type ApiResponse<T> = T extends 'success' ? SuccessData : ErrorData;
```

#### 5. **Mapped Types** - Can you transform known structures?
```typescript
// ‚ùå PROHIBITED: Unknown for object transformations
type TransformedData = Record<string, unknown>;

// ‚úÖ REQUIRED: Use mapped types
type TransformedData<T> = {
  [K in keyof T]: string;
};
```

#### 6. **Type Guards** - Can you narrow unknown inputs?
```typescript
// ‚ùå PROHIBITED: Accepting unknown without validation
function process(data: unknown): void {
  // Direct usage without validation
}

// ‚úÖ REQUIRED: Use type guards to narrow
function process(data: unknown): void {
  if (isValidData(data)) {
    // Now data is properly typed
  }
}

function isValidData(data: unknown): data is ValidDataType {
  return typeof data === 'object' && data !== null && 'id' in data;
}
```

#### 7. **Interface Definition** - Can you define a specific interface?
```typescript
// ‚ùå PROHIBITED: Unknown for structured data
function handleApiResponse(response: unknown): void {}

// ‚úÖ REQUIRED: Define specific interfaces
interface ApiResponse {
  status: 'success' | 'error';
  data?: ResponseData;
  error?: ErrorInfo;
}
function handleApiResponse(response: ApiResponse): void {}
```

### ‚úÖ EXCEPTIONAL CASES: Only When NO Alternative Exists

`any`/`unknown` may ONLY be used in these exceptional cases:

#### 1. **External JSON Parsing** (Input genuinely unknown)
```typescript
// ‚úÖ ACCEPTABLE: JSON structure is truly unknown
function parseExternalJSON(jsonString: string): unknown {
  // REASON: External JSON structure is genuinely unpredictable
  // ALTERNATIVES_CONSIDERED: Cannot predict external API response structure
  // TODO: Add runtime validation and type narrowing after parsing
  return JSON.parse(jsonString);
}
```

#### 2. **Third-party Library Integration** (No type definitions available)
```typescript
// ‚úÖ ACCEPTABLE: External library with no types
const result = (window as any).legacyLibrary.undocumentedMethod();
// REASON: Legacy browser library with no TypeScript definitions available
// ALTERNATIVES_CONSIDERED: No @types package exists, vendor provides no types
// TODO: Create custom type declarations or replace with typed alternative
```

#### 3. **JavaScript Migration** (Temporary during conversion)
```typescript
// ‚úÖ ACCEPTABLE: Temporary during JS to TS migration
let legacyData: any;
// REASON: Legacy JavaScript code being incrementally migrated
// ALTERNATIVES_CONSIDERED: Cannot determine type without extensive legacy code analysis
// TODO: Analyze legacy usage patterns and replace with specific type
```

### üìù MANDATORY DOCUMENTATION FORMAT

Every `any`/`unknown` usage MUST include this exact format:

```typescript
// REASON: [Specific technical reason why NO alternative exists]
// ALTERNATIVES_CONSIDERED: [List ALL alternatives you verified as impossible]
// TODO: [Mandatory - specific plan to eliminate any/unknown in the future]
const data: unknown = externalSource;
```

**Example of complete documentation:**
```typescript
// REASON: External API returns unpredictable JSON structure varying by endpoint
// ALTERNATIVES_CONSIDERED: Union types (impossible - infinite variations), 
//                          Generic types (no way to parameterize unknown structure),
//                          Conditional types (no condition to base on),
//                          Interface definition (structure varies completely)
// TODO: Implement runtime schema validation with Zod and create specific types per endpoint
const apiResponse: unknown = await fetch('/api/dynamic-endpoint').then(r => r.json());
```

### üîç PRE-IMPLEMENTATION VERIFICATION CHECKLIST

Before using `any`/`unknown`, you MUST answer "NO" to ALL of these:

- [ ] Can I use a union type (e.g., `string | number | boolean`)?
- [ ] Can I use a generic type parameter (e.g., `<T>` or `<T extends SomeType>`)?
- [ ] Can I define a specific interface for this data structure?
- [ ] Can I use conditional types to determine the type?
- [ ] Can I use mapped types to transform known types?
- [ ] Can I extend existing interfaces or types?
- [ ] Can I use intersection types to combine known types?
- [ ] Can I create type guards to narrow the type?
- [ ] Can I use utility types (Partial, Pick, Omit, etc.)?
- [ ] Is there a @types package available for external libraries?
- [ ] Can I create custom type declarations for external code?
- [ ] Can I refactor the code to avoid needing unknown types?

**If ANY answer is "YES", you CANNOT use `any`/`unknown`.**

### üö® ENFORCEMENT AND CODE REVIEW

#### Code Review Requirements:
- [ ] Reviewer MUST verify all 12 alternatives were genuinely considered
- [ ] REASON must be specific and technically sound
- [ ] ALTERNATIVES_CONSIDERED must list actual attempts, not assumptions
- [ ] TODO must include specific, actionable improvement plan
- [ ] Scope of `any`/`unknown` must be absolutely minimal
- [ ] Must have clear timeline for elimination

#### CI/CD Pipeline:
- ESLint rules: `@typescript-eslint/no-explicit-any` and `@typescript-eslint/ban-types`
- Custom lint rule to verify comment format
- All `any`/`unknown` usage requires manual approval
- Automatic TODO tracking for future type improvements

### ‚ùå EXAMPLES: UNACCEPTABLE Usage

```typescript
// ‚ùå WRONG: Lazy typing
let config: any = { host: 'localhost' }; // Should be specific interface

// ‚ùå WRONG: Avoiding type complexity  
function process(data: unknown): void {} // Should define specific types

// ‚ùå WRONG: Plugin extensibility
interface PluginContext {
  [key: string]: unknown; // Should use specific value types
}

// ‚ùå WRONG: Missing alternatives consideration
const result: any = complexFunction(); // No documentation or alternatives
```

### ‚úÖ EXAMPLES: ACCEPTABLE Usage (Rare)

```typescript
// ‚úÖ CORRECT: External JSON with proper documentation
function parseUserSubmittedJSON(input: string): unknown {
  // REASON: User-submitted JSON can contain any valid JSON structure
  // ALTERNATIVES_CONSIDERED: Union types (infinite possibilities),
  //                          Interface (user controls structure),
  //                          Generic (no way to parameterize user input)
  // TODO: Implement Zod schema validation to convert to typed structures
  return JSON.parse(input);
}

// ‚úÖ CORRECT: Legacy integration with migration plan
declare const legacyGlobal: any;
// REASON: Legacy global variable from 10-year-old jQuery plugin
// ALTERNATIVES_CONSIDERED: Custom types (plugin source unavailable),
//                          @types package (doesn't exist),
//                          Refactoring (requires 6-month migration)
// TODO: Replace with modern typed alternative by Q2 2024
```

### üìä TRACKING AND METRICS

Maintain metrics on:
- Total count of `any`/`unknown` usages
- Age of each usage (how long it's been in codebase)
- Progress on TODO elimination plans
- New additions (should trend toward zero)

### Reference Implementations

See proper type safety examples in:
- [base-plugin.ts](mdc:packages/agents/src/abstracts/base-plugin.ts) - Specific context types
- [tool.ts](mdc:packages/agents/src/interfaces/tool.ts) - Type ownership patterns
- [conversation-history-manager.ts](mdc:packages/agents/src/managers/conversation-history-manager.ts) - Semantic naming

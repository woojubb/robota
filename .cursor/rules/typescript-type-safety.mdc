---
description: 
globs: 
alwaysApply: false
---
# TypeScript Type Safety Rules - Zero Any/Unknown Policy

## üö® ABSOLUTE PROHIBITION: any/unknown Types

### Rule 1: Complete any/unknown Ban
**NO any or unknown types are permitted in the codebase except for user-explicitly requested edge cases.**

**Type complexity is NOT a valid reason for any/unknown usage.**

The codebase provides comprehensive solutions:
- **Generic Type Parameters**: `<TConfig, TMessage, TResponse>`
- **Facade Pattern Architecture**: Complex types broken into manageable pieces
- **Type Parameter Constraints**: `T extends Record<string, ConfigValue>`
- **Default Type Parameters**: Backward compatibility maintained

### Rule 2: Mandatory Pattern Application
When facing complex typing challenges, you MUST use:

```typescript
// ‚úÖ REQUIRED: Generic Type Parameters with Constraints
interface BaseProvider<
  TConfig extends Record<string, ConfigValue>,
  TMessage extends UniversalMessage,
  TResponse extends ProviderResponse
> {
  configure(config: TConfig): Promise<void>;
  process(message: TMessage): Promise<TResponse>;
}

// ‚úÖ REQUIRED: Facade Pattern for Complex Types
// Create separate files: types.ts, interfaces.ts, adapters/, transformers/
```

### Rule 3: Provider-Agnostic Design Enforcement
All provider integrations MUST follow the established pattern:

```typescript
// ‚úÖ CORRECT: Provider-neutral with explicit generics
export class OpenAIProvider extends BaseAIProvider<
  OpenAIProviderOptions, 
  UniversalMessage, 
  UniversalMessage
> {
  // Implementation uses OpenAI-specific types internally
  // Exposes only UniversalMessage externally
}

// ‚ùå FORBIDDEN: any types for "simplicity"
const requestParams: any = { ... }; // VIOLATION
```

### Rule 4: Only 2 Exceptional Cases Permitted
1. **External Library Streaming Protocol Issues**: When 3rd party SDK has broken TypeScript definitions
2. **User Explicitly Requests Legacy Compatibility**: Only with explicit user approval

### Rule 5: Required Exception Documentation
When user explicitly allows any/unknown:

```typescript
// REASON: [User requested legacy compatibility for specific migration scenario]
// ALTERNATIVES_CONSIDERED: [All 12 pattern-based alternatives verified and documented]
// USER_APPROVAL: [Explicit user consent with date and context]
// TODO: [Mandatory timeline to eliminate any/unknown]
const data: any = userRequestedLegacyCode();
```

## Type Architecture Patterns

### Central Type Authorities
- **[interfaces/tool.ts](mdc:packages/agents/src/interfaces/tool.ts)**: All tool-related types
- **[interfaces/agent.ts](mdc:packages/agents/src/interfaces/agent.ts)**: Agent and message types  
- **[abstracts/base-ai-provider.ts](mdc:packages/agents/src/abstracts/base-ai-provider.ts)**: Provider type system
- **Provider-specific api-types.ts**: Each provider's native API types

### Generic Type Parameter System
```typescript
// ‚úÖ PATTERN: Explicit type parameters with defaults
interface BaseAgent<
  TConfig = AgentConfig,
  TContext = ExecutionContext, 
  TResult = ExecutionResult
> {
  configure(config: TConfig): Promise<void>;
  execute(context: TContext): Promise<TResult>;
}

// ‚úÖ PATTERN: Type constraints for safety
interface BaseTool<
  TParameters extends Record<string, ConfigValue>,
  TResult extends ToolExecutionResult
> {
  execute(params: TParameters): Promise<TResult>;
}
```

### Facade Pattern Implementation
```typescript
// ‚úÖ PATTERN: Complex types broken into modules
// src/components/webhook/
//   ‚îú‚îÄ‚îÄ types.ts          # Core type definitions
//   ‚îú‚îÄ‚îÄ interfaces.ts     # Public contracts
//   ‚îú‚îÄ‚îÄ adapters/         # Type conversion logic
//   ‚îú‚îÄ‚îÄ validators/       # Type validation
//   ‚îî‚îÄ‚îÄ index.ts          # Clean facade export
```

### Import-Only Type Ownership
```typescript
// ‚úÖ CORRECT: Import from type authority
import type { ToolParameters, ToolResult } from '../interfaces/tool';

// ‚ùå FORBIDDEN: Local type redefinition
type ToolParameters = Record<string, unknown>; // VIOLATION
```

## Advanced Type Patterns

### Pattern 1: Provider Type Conversion
```typescript
// ‚úÖ Internal provider types ‚Üí Universal types
private convertToUniversalMessage(
  openaiResponse: OpenAI.Chat.ChatCompletion
): UniversalMessage {
  // Type-safe conversion logic
}
```

### Pattern 2: Conditional Type Safety
```typescript
// ‚úÖ Type-safe conditional logic
type ProviderMessage<T extends string> = T extends 'openai' 
  ? OpenAIMessage 
  : T extends 'anthropic'
  ? AnthropicMessage
  : UniversalMessage;
```

### Pattern 3: Utility Type Composition
```typescript
// ‚úÖ Complex types from utility combinations
type PartialConfig<T> = Partial<Pick<T, keyof T>>;
type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;
```

## Enforcement Guidelines

### For Code Reviews
- **Immediate rejection** of any PR containing any/unknown without user approval
- **Mandatory pattern application** for all type challenges
- **Architecture compliance** verification for all provider integrations

### For Development
- **Use established patterns** before attempting custom solutions
- **Leverage generic type system** for all base classes
- **Apply facade pattern** for complex type structures
- **Import from type authorities** - never duplicate type definitions

### For Refactoring
- **Convert any/unknown** to proper generic patterns immediately
- **Establish type ownership** for new type definitions
- **Apply constraints** to all generic type parameters
- **Maintain backward compatibility** through default type parameters

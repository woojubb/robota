---
description:
globs:
alwaysApply: false
---
# íƒ€ì… ë§¤ê°œë³€ìˆ˜ì™€ ê³ ê¸‰ Facade íŒ¨í„´ ê°€ì´ë“œ

## ğŸ¯ ëª©í‘œ

íƒ€ì… ì•ˆì „ì„±ì„ ìœ ì§€í•˜ë©´ì„œ ì½”ë“œ ì¬ì‚¬ìš©ì„±ê³¼ ìœ ì—°ì„±ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•œ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì™€ ê³ ê¸‰ Facade íŒ¨í„´ ë„ì… ê°€ì´ë“œì…ë‹ˆë‹¤.

## ğŸ“‹ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì„¤ê³„ ì›ì¹™

### ğŸš¨ ì¤‘ìš”: ëª…ëª… ê·œì¹™ ë° ì„¤ê³„ ì² í•™

1. **ëª…ëª… ì›ì¹™**: "ì œë„¤ë¦­"ì´ë¼ëŠ” ìš©ì–´ë¥¼ ì½”ë“œë‚˜ íƒ€ì…ëª…ì— ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì œë„¤ë¦­ì€ êµ¬í˜„ ë°©ì‹ì´ì§€ ì´ë¦„ì´ ì•„ë‹™ë‹ˆë‹¤.
2. **Provider ë¶ˆê°€ì§€ë¡ **: agents ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” íŠ¹ì • AI Provider(OpenAI, Anthropic ë“±)ë¥¼ ì•Œì§€ ì•ŠìŠµë‹ˆë‹¤.
3. **ë™ì  êµ¬ì¡°**: `aiProviders['openai']` í˜•íƒœë¡œ ëŸ°íƒ€ì„ì— Providerë¥¼ ë“±ë¡í•˜ê³  ì‚¬ìš©í•©ë‹ˆë‹¤.

### 1. íƒ€ì… ë§¤ê°œë³€ìˆ˜ ëª…ëª… ê·œì¹™

```typescript
// âœ… ê¶Œì¥: ëª…í™•í•˜ê³  ì„¤ëª…ì ì¸ ì´ë¦„
interface BaseAgent<TConfig, TContext, TResult> {
  configure(config: TConfig): Promise<void>;
  execute(context: TContext): Promise<TResult>;
}

// âœ… Provider ì¤‘ë¦½ì  ì„¤ê³„
interface BaseAIProvider<TConfig, TMessage, TResponse> {
  configure(config: TConfig): void;
  sendMessage(message: TMessage): Promise<TResponse>;
}

// âœ… Tool íƒ€ì… ë§¤ê°œë³€ìˆ˜
interface BaseTool<TParameters, TResult> {
  execute(parameters: TParameters): Promise<TResult>;
}

// âœ… Plugin íƒ€ì… ë§¤ê°œë³€ìˆ˜
interface BasePlugin<TOptions, TContext, TStats> {
  initialize(options: TOptions): Promise<void>;
  process(context: TContext): Promise<void>;
  getStats(): TStats;
}
```

### 2. ë™ì  Provider íƒ€ì… ì‹œìŠ¤í…œ

```typescript
// âœ… Provider ë¶ˆê°€ì§€ë¡ ì  ì„¤ê³„
interface BaseAIProvider<TConfig, TMessage, TResponse> {
  configure(config: TConfig): void;
  sendMessage(message: TMessage): Promise<TResponse>;
}

// âœ… ë™ì  Provider ë“±ë¡
interface AgentConfig {
  aiProviders?: Record<string, BaseAIProvider<any, any, any>>;
  currentProvider?: string;
}
```

### 3. íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì œì•½ ì¡°ê±´ (Constraints)

```typescript
// âœ… ê¸°ë³¸ ì œì•½ ì¡°ê±´
interface BaseAgent<
  TConfig extends Record<string, unknown>,
  TContext extends ExecutionContext,
  TResult extends ExecutionResult
> {
  // êµ¬í˜„
}

// âœ… ì¡°ê±´ë¶€ íƒ€ì… í™œìš© (Provider ì¤‘ë¦½ì )
type ProviderMessage<T extends string> = T extends string 
  ? UniversalMessage 
  : never;

// âœ… í‚¤ ì œì•½ ì¡°ê±´
interface ToolRegistry<K extends string, T extends BaseTool<any, any>> {
  register(name: K, tool: T): void;
  get(name: K): T | undefined;
}
```

### 4. ê¸°ë³¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ (Default Type Parameters)

```typescript
// âœ… í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ê¸°ë³¸ íƒ€ì… ì œê³µ
interface BaseAgent<
  TConfig = AgentConfig,
  TContext = ExecutionContext,
  TResult = ExecutionResult
> {
  // ê¸°ì¡´ ì½”ë“œì™€ í˜¸í™˜ì„± ìœ ì§€
}

// âœ… ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì§€ì›
interface BaseAIProvider<
  TConfig = ProviderConfig,
  TMessage = UniversalMessage,
  TResponse = ProviderResponse
> {
  // ê¸°ì¡´ ì‚¬ìš©ë²•: new CustomProvider()
  // ìƒˆë¡œìš´ ì‚¬ìš©ë²•: new CustomProvider<CustomConfig, CustomMessage, CustomResponse>()
}
```

## ğŸ—ï¸ ê³ ê¸‰ Facade íŒ¨í„´

### 1. í´ë” êµ¬ì¡° í‘œì¤€

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ [component-name]/
â”‚   â”‚   â”œâ”€â”€ types.ts          # íƒ€ì… ì •ì˜
â”‚   â”‚   â”œâ”€â”€ interfaces.ts     # ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ adapters/         # ì–´ëŒ‘í„° íŒ¨í„´
â”‚   â”‚   â”œâ”€â”€ validators/       # ê²€ì¦ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ transformers/     # ë³€í™˜ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ [component].ts    # ë©”ì¸ í´ë˜ìŠ¤
â”‚   â”‚   â””â”€â”€ index.ts          # í†µí•© export
```

### 2. íƒ€ì… ì •ì˜ ë¶„ë¦¬

```typescript
// types.ts - ëª¨ë“  íƒ€ì… ì •ì˜
export interface ComponentConfig<T = unknown> {
  enabled: boolean;
  options: T;
}

export interface ComponentContext<TData = unknown> {
  executionId: string;
  data: TData;
  metadata: Record<string, unknown>;
}

export interface ComponentResult<TOutput = unknown> {
  success: boolean;
  output: TOutput;
  duration: number;
}

// interfaces.ts - ì¸í„°í˜ì´ìŠ¤ ì •ì˜
export interface ComponentInterface<TConfig, TContext, TResult> {
  initialize(config: TConfig): Promise<void>;
  process(context: TContext): Promise<TResult>;
  cleanup(): Promise<void>;
}
```

### 3. ì–´ëŒ‘í„° íŒ¨í„´ êµ¬í˜„

```typescript
// adapters/context-adapter.ts
export class ContextAdapter<TInput, TOutput> {
  constructor(
    private transformer: (input: TInput) => TOutput
  ) {}

  adapt(input: TInput): TOutput {
    try {
      return this.transformer(input);
    } catch (error) {
      throw new AdapterError('Context adaptation failed', { input, error });
    }
  }
}

// adapters/config-adapter.ts
export class ConfigAdapter<TSource, TTarget> {
  static create<S, T>(
    schema: Schema<T>,
    transformer: (source: S) => T
  ): ConfigAdapter<S, T> {
    return new ConfigAdapter(schema, transformer);
  }

  private constructor(
    private schema: Schema<TTarget>,
    private transformer: (source: TSource) => TTarget
  ) {}

  adapt(source: TSource): TTarget {
    const transformed = this.transformer(source);
    return this.schema.parse(transformed);
  }
}
```

### 4. ê²€ì¦ ì‹œìŠ¤í…œ

```typescript
// validators/type-validator.ts
export class TypeValidator<T> {
  constructor(
    private guards: Array<(value: unknown) => value is T>
  ) {}

  validate(value: unknown): value is T {
    return this.guards.every(guard => guard(value));
  }

  assert(value: unknown, context?: string): asserts value is T {
    if (!this.validate(value)) {
      throw new ValidationError(`Type validation failed${context ? `: ${context}` : ''}`, {
        value,
        expectedType: this.constructor.name
      });
    }
  }
}

// validators/schema-validator.ts
export class SchemaValidator<T> {
  constructor(private schema: Schema<T>) {}

  validate(value: unknown): ValidationResult<T> {
    try {
      const parsed = this.schema.parse(value);
      return { success: true, data: parsed };
    } catch (error) {
      return { 
        success: false, 
        errors: error instanceof ZodError ? error.errors : [{ message: String(error) }]
      };
    }
  }

  assert(value: unknown): T {
    const result = this.validate(value);
    if (!result.success) {
      throw new ValidationError('Schema validation failed', {
        errors: result.errors,
        value
      });
    }
    return result.data;
  }
}
```

## ğŸ”§ êµ¬í˜„ ë‹¨ê³„ë³„ ê°€ì´ë“œ

### Phase 1: ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ íƒ€ì… ë§¤ê°œë³€ìˆ˜í™”

1. **BaseAgent íƒ€ì… ë§¤ê°œë³€ìˆ˜í™”**
   ```typescript
   // ê¸°ì¡´
   interface BaseAgent {
     configure(config: AgentConfig): Promise<void>;
   }

   // ìƒˆë¡œìš´ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ë²„ì „
   interface BaseAgent<TConfig = AgentConfig> {
     configure(config: TConfig): Promise<void>;
   }
   ```

2. **ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜**
   - ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„± ìœ ì§€
   - ìƒˆë¡œìš´ íƒ€ì… ë§¤ê°œë³€ìˆ˜ API ì ì§„ì  ë„ì…
   - íƒ€ì… ì•ˆì „ì„± ë‹¨ê³„ë³„ ê°•í™”

### Phase 2: ë™ì  Provider ì‹œìŠ¤í…œ íƒ€ì… ë§¤ê°œë³€ìˆ˜ í†µí•©

1. **Provider ì¤‘ë¦½ì  íƒ€ì… ì •ì˜**
   ```typescript
   // âœ… Provider ë¶ˆê°€ì§€ë¡ ì  ì„¤ê³„
   interface BaseAIProvider<TConfig, TMessage, TResponse> {
     configure(config: TConfig): void;
     sendMessage(message: TMessage): Promise<TResponse>;
   }

   // âœ… ë™ì  Provider ë“±ë¡
   interface AgentConfig {
     aiProviders: BaseAIProvider<any, any, any>[];
     defaultModel: {
       provider: string;
       model: string;
     };
   }
   ```

2. **íƒ€ì… ì•ˆì „í•œ ë©”ì‹œì§€ ë³€í™˜**
   ```typescript
   class MessageTransformer<TSource, TTarget> {
     transform(message: TSource): TTarget {
       // íƒ€ì… ì•ˆì „í•œ ë³€í™˜ ë¡œì§
     }
   }
   ```

### Phase 3: Tool ì‹œìŠ¤í…œ íƒ€ì… ë§¤ê°œë³€ìˆ˜í™”

1. **íƒ€ì… ì•ˆì „í•œ ë„êµ¬ ë§¤ê°œë³€ìˆ˜**
   ```typescript
   interface BaseTool<TParams, TResult> {
     execute(params: TParams): Promise<TResult>;
     validateParameters(params: unknown): params is TParams;
   }
   ```

2. **ëŸ°íƒ€ì„ ê²€ì¦ í†µí•©**
   ```typescript
   class TypeSafeTool<TParams, TResult> extends BaseTool<TParams, TResult> {
     constructor(
       private schema: Schema<TParams>,
       private executor: (params: TParams) => Promise<TResult>
     ) {
       super();
     }

     async execute(params: TParams): Promise<TResult> {
       this.schema.parse(params); // ëŸ°íƒ€ì„ ê²€ì¦
       return this.executor(params);
     }
   }
   ```

## ğŸ“ ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### 1. íƒ€ì… ì»´íŒŒì¼ ìµœì í™”

```typescript
// âŒ í”¼í•  ê²ƒ: ê³¼ë„í•˜ê²Œ ë³µì¡í•œ íƒ€ì… ë§¤ê°œë³€ìˆ˜
type OverlyComplex<T> = T extends Record<infer K, infer V> 
  ? K extends string 
    ? V extends Record<infer K2, infer V2>
      ? K2 extends string
        ? Record<K, Record<K2, V2>>
        : never
      : never
    : never
  : never;

// âœ… ê¶Œì¥: ë‹¨ìˆœí•˜ê³  ëª…í™•í•œ íƒ€ì… ë§¤ê°œë³€ìˆ˜
type SimpleRecord<K extends string, V> = Record<K, V>;
```

### 2. ì¡°ê±´ë¶€ íƒ€ì… ìµœì í™”

```typescript
// âœ… íš¨ìœ¨ì ì¸ ì¡°ê±´ë¶€ íƒ€ì… (Provider ì¤‘ë¦½ì )
type ProviderType<T extends string> = T extends string ? BaseAIProvider : never;

// âœ… íƒ€ì… ë§¤í•‘ í™œìš© (ë™ì  Provider ì§€ì›)
type ProviderMap<T extends Record<string, BaseAIProvider<any, any, any>>> = {
  [K in keyof T]: T[K];
};
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. íƒ€ì… ë ˆë²¨ í…ŒìŠ¤íŠ¸

```typescript
// type-tests.ts
import { expectType, expectError, expectAssignable } from 'tsd';

// íƒ€ì… ë§¤ê°œë³€ìˆ˜ ê²€ì¦
expectType<BaseAIProvider<any, any, any>>(new CustomProvider());

// íƒ€ì… í˜¸í™˜ì„± ê²€ì¦
expectAssignable<BaseAgent>(new CustomAgent());

// íƒ€ì… ì—ëŸ¬ ê²€ì¦
expectError(new BaseTool<string, number>().execute(123)); // ì˜ëª»ëœ ë§¤ê°œë³€ìˆ˜ íƒ€ì…
```

### 2. ëŸ°íƒ€ì„ ê²€ì¦ í…ŒìŠ¤íŠ¸

```typescript
describe('Type Parameter Safety', () => {
  it('should validate parameters at runtime', async () => {
    const tool = new TypeSafeTool(
      z.object({ name: z.string() }),
      async (params) => `Hello, ${params.name}!`
    );

    await expect(tool.execute({ name: 'World' })).resolves.toBe('Hello, World!');
    await expect(tool.execute({ age: 25 } as any)).rejects.toThrow();
  });
});
```

## ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ

### 1. ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„± ìœ ì§€

```typescript
// ê¸°ì¡´ ì‚¬ìš©ë²• (DEPRECATED - í˜¸í™˜ì„± ìœ ì§€ìš©)
const agent = new RobotaAgent({
  model: 'gpt-4',
  provider: 'openai',
  aiProviders: [openaiProvider],
  defaultModel: {
    provider: 'openai',
    model: 'gpt-4'
  }
});

// ìƒˆë¡œìš´ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì‚¬ìš©ë²•
const typedAgent = new RobotaAgent<CustomConfig, CustomContext, CustomResult>({
  name: 'TypedAgent',
  aiProviders: [openaiProvider],
  defaultModel: {
    provider: 'openai',
    model: 'gpt-4'
  }
});
```

### 2. ë‹¨ê³„ì  íƒ€ì… ê°•í™”

```typescript
// Step 1: ê¸°ë³¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ë„ì…
interface MyTool extends BaseTool<Record<string, unknown>, unknown> {}

// Step 2: êµ¬ì²´ì  íƒ€ì… ì •ì˜
interface MyToolParams {
  query: string;
  options?: SearchOptions;
}

interface MyToolResult {
  results: SearchResult[];
  metadata: SearchMetadata;
}

// Step 3: ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±
interface MyTool extends BaseTool<MyToolParams, MyToolResult> {}
```

ì´ ê°€ì´ë“œë¥¼ ë”°ë¼ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì™€ ê³ ê¸‰ Facade íŒ¨í„´ì„ ë‹¨ê³„ì ìœ¼ë¡œ ë„ì…í•˜ì—¬ íƒ€ì… ì•ˆì „ì„±ê³¼ ì½”ë“œ ì¬ì‚¬ìš©ì„±ì„ ê·¹ëŒ€í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

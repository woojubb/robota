# Universal Dependency Separation & Event-Driven Architecture Rules

## üö´ ABSOLUTE FORBIDDEN PATTERNS

### Direct Component References (NEVER ALLOWED)
```typescript
// ‚ùå FORBIDDEN: Any class directly referencing another extensible component
export class LoggingService extends BaseService {
    constructor(private analyticsService: AnalyticsService) {} // NEVER DO THIS
}

// ‚ùå FORBIDDEN: Service referencing Plugin  
export class DatabaseService extends BaseService {
    constructor(private cachingPlugin: CachingPlugin) {} // NEVER DO THIS
}

// ‚ùå FORBIDDEN: Plugin referencing Plugin
export class MetricsPlugin extends BasePlugin {
    constructor(private loggingPlugin: LoggingPlugin) {} // NEVER DO THIS
}

// ‚ùå FORBIDDEN: Extension referencing Extension directly
export class AuthExtension extends BaseExtension {
    constructor(private validationExtension: ValidationExtension) {} // NEVER DO THIS
}

// ‚ùå FORBIDDEN: Manager cross-references
export class ServiceManager {
    constructor(private pluginManager: PluginManager) {} // NEVER DO THIS
}

// ‚ùå FORBIDDEN: Bridge/Adapter pattern for component coupling
export class ServicePluginBridge {
    constructor(serviceRegistry: ServiceRegistry, pluginManager: PluginManager) {} // NEVER DO THIS
}
```

## ‚úÖ REQUIRED PATTERNS

### Event-Driven Communication ONLY
```typescript
// ‚úÖ CORRECT: Component emits events, no direct references
export class DatabaseService extends BaseService {
    async saveUser(user: User): Promise<void> {
        // Emit start event
        this.emitEvent('service.database.save.start', { 
            serviceId: this.name, 
            operation: 'saveUser',
            entityType: 'User',
            timestamp: Date.now() 
        });
        
        const result = await this.performSave(user);
        
        // Emit completion event
        this.emitEvent('service.database.save.complete', { 
            serviceId: this.name, 
            operation: 'saveUser',
            entityType: 'User',
            success: true,
            timestamp: Date.now() 
        });
    }
}

// ‚úÖ CORRECT: Plugin listens to events, no direct references
export class AuditLogPlugin extends BasePlugin {
    async initialize(): Promise<void> {
        // Subscribe to events without knowing who emits them
        this.eventEmitter.on('service.database.save.start', (event) => {
            this.log(`Database operation started: ${event.data.operation} on ${event.data.entityType}`);
        });
        
        this.eventEmitter.on('service.database.save.complete', (event) => {
            this.log(`Database operation completed: ${event.data.operation} - Success: ${event.data.success}`);
        });
    }
}

// ‚úÖ CORRECT: Main application class provides shared EventEmitter
export class Application {
    constructor(config: ApplicationConfig) {
        // Central EventEmitter - only communication hub
        const eventEmitter = new EventEmitter();
        
        // Each component gets EventEmitter but no direct references to each other
        const databaseService = new DatabaseService(config.database);
        databaseService.setEventEmitter(eventEmitter);
        
        const auditPlugin = new AuditLogPlugin(config.audit);
        auditPlugin.setEventEmitter(eventEmitter);
        
        // NO bridge, NO cross-references, NO direct dependencies
    }
}
```

### Inter-Component Communication via Events
```typescript
// ‚úÖ CORRECT: Service requests another Service's functionality via events
export class UserService extends BaseService {
    async createUser(userData: UserData): Promise<User> {
        // Request validation service via event
        this.emitEvent('validation.user.request', {
            requestor: this.name,
            data: userData,
            requestId: this.generateRequestId()
        });
        
        // Wait for validation response
        return new Promise((resolve, reject) => {
            this.eventEmitter.once('validation.user.response', (event) => {
                if (event.data.requestId === this.currentRequestId) {
                    if (event.data.success) {
                        this.proceedWithUserCreation(userData).then(resolve);
                    } else {
                        reject(new Error(event.data.error));
                    }
                }
            });
        });
    }
}

// ‚úÖ CORRECT: Validation Service responds to requests via events
export class ValidationService extends BaseService {
    async initialize(): Promise<void> {
        this.eventEmitter.on('validation.user.request', async (event) => {
            const validationResult = await this.validateUserData(event.data.data);
            
            this.emitEvent('validation.user.response', {
                requestId: event.data.requestId,
                requestor: event.data.requestor,
                success: validationResult.isValid,
                error: validationResult.error,
                timestamp: Date.now()
            });
        });
    }
}
```

## üîç VALIDATION RULES

### Before Creating Any Component, Check:

1. **Zero Knowledge Test**: 
   - ‚ùì Does this component know about ANY other specific component class?
   - ‚úÖ PASS: Only knows about EventEmitter and base interfaces
   - ‚ùå FAIL: Knows about specific Service/Plugin/Extension names or types

2. **Removal Test**:
   - ‚ùì If I delete this component, does the core system break?
   - ‚úÖ PASS: System works, just missing this feature/capability
   - ‚ùå FAIL: System crashes or core functionality stops

3. **Communication Test**:
   - ‚ùì How does this component communicate with others?
   - ‚úÖ PASS: Only through EventEmitter events
   - ‚ùå FAIL: Direct method calls, property access, or constructor injection

4. **Responsibility Test**:
   - ‚ùì What is this component's single responsibility?
   - ‚úÖ PASS: Clear, focused responsibility that's optional or extensible
   - ‚ùå FAIL: Core system functionality that cannot be removed

### Mandatory Event Patterns

```typescript
// Service events - standardized format
this.emitEvent('service.{service-name}.{operation}.{status}', {
    serviceId: string,          // Always include
    timestamp: number,          // Always include
    operation: string,          // What operation
    // ... operation-specific data
});

// Plugin events - standardized format  
this.emitEvent('plugin.{plugin-name}.{lifecycle}', {
    pluginId: string,           // Always include
    timestamp: number,          // Always include
    status: string,             // initialized|error|disabled
    // ... plugin-specific data
});

// Extension events - standardized format
this.emitEvent('extension.{extension-name}.{event}', {
    extensionId: string,        // Always include
    timestamp: number,          // Always include
    eventType: string,          // What happened
    // ... extension-specific data
});

// Inter-component requests - standardized format
this.emitEvent('{target-component}.{operation}.request', {
    requestor: string,          // Always include requesting component name
    requestId: string,          // Always include unique request ID
    timestamp: number,          // Always include
    // ... request-specific data
});

// Inter-component responses - standardized format
this.emitEvent('{target-component}.{operation}.response', {
    requestId: string,          // Must match request
    requestor: string,          // Must match request
    timestamp: number,          // Always include
    success: boolean,           // Always include
    // ... response data or error info
});
```

## üö® CODE REVIEW CHECKLIST

When reviewing ANY code in the project:

- [ ] **No direct imports** of extensible component classes except in main application constructor
- [ ] **No constructor injection** of components into each other
- [ ] **No method calls** between extensible components (only EventEmitter)
- [ ] **No property access** between extensible components
- [ ] **No Bridge/Adapter classes** or intermediate coupling layers
- [ ] **EventEmitter used** for ALL inter-component communication
- [ ] **Events follow naming convention** (component.name.operation.status)
- [ ] **Event data includes** componentId, timestamp, requestId (when applicable)
- [ ] **Component can be removed** without breaking core system functionality
- [ ] **Single responsibility** clearly defined and followed

## üéØ QUICK DECISION TREE

```
New component needed?
‚îú‚îÄ‚îÄ Is it core system functionality?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Core class (direct dependencies allowed)
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Continue
‚îú‚îÄ‚îÄ Is it optional/removable without breaking core system?
‚îÇ   ‚îú‚îÄ‚îÄ NO ‚Üí Core class (direct dependencies allowed)
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Continue
‚îú‚îÄ‚îÄ Will other components need to interact with it?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Use Event-Driven pattern (no direct dependencies)
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Isolated component (direct dependencies allowed)
```

## üîß ARCHITECTURAL ENFORCEMENT

This rule applies to ALL extensible components:
- Services (`*Service.ts`)
- Plugins (`*Plugin.ts`) 
- Extensions (`*Extension.ts`)
- Managers (`*Manager.ts`)
- Any class that can be optionally added/removed
- Any class that other classes might need to interact with

**Exceptions allowed ONLY for:**
- Core system classes that are always required
- Utility classes with no state
- Pure data transfer objects (DTOs)
- Base interfaces and abstract classes

**Event-Driven architecture is MANDATORY for all extensible components.**

---
description: 
globs: 
alwaysApply: false
---
# TypeScript Type Deduplication Rules

## Overview
This rule enforces centralized type management to prevent duplicate type declarations across multiple files in the Robota agents package.

## Type Ownership Hierarchy

### 1. Central Type Authorities
These files are the ONLY sources of truth for their respective type domains:

- **[interfaces/tool.ts](mdc:packages/agents/src/interfaces/tool.ts)** - ALL tool-related types
- **[utils/errors.ts](mdc:packages/agents/src/utils/errors.ts)** - ALL error context types
- **[interfaces/agent.ts](mdc:packages/agents/src/interfaces/agent.ts)** - ALL agent and message types
- **[abstracts/base-plugin.ts](mdc:packages/agents/src/abstracts/base-plugin.ts)** - ALL base plugin types

### 2. Plugin-Specific Type Ownership
Each plugin owns ONLY its specialized types:

```typescript
// ✅ CORRECT: Each plugin owns its unique statistics/config types
// execution-analytics-plugin.ts
export interface ExecutionAnalyticsStats { ... }
export interface AnalyticsContextData { ... }

// error-handling-plugin.ts  
export interface ErrorHandlingPluginStats { ... }
export interface ErrorHandlingContextData { ... }

// logging-plugin.ts
export interface LoggingPluginStats { ... }
export interface LoggingContextData { ... }
```

### 3. Shared Type Management
For types used across multiple plugins:

```typescript
// ✅ CORRECT: Define once in central authority
// interfaces/plugin.ts
export interface BaseExecutionContext {
    executionId?: string;
    sessionId?: string;
    userId?: string;
}

// Plugin files import and extend
import type { BaseExecutionContext } from '../interfaces/plugin';
export interface LoggingContextData extends BaseExecutionContext {
    logLevel?: string;
}
```

## Mandatory Rules

### Rule 1: No Duplicate Type Declarations
**VIOLATION:**
```typescript
// ❌ WRONG: Same type declared in multiple files
// File A
export interface UserContext { userId: string; }

// File B  
export interface UserContext { userId: string; }
```

**CORRECTION:**
```typescript
// ✅ CORRECT: Single source of truth
// interfaces/shared.ts
export interface UserContext { userId: string; }

// File A & B
import type { UserContext } from '../interfaces/shared';
```

### Rule 2: Context Data Type Unification
**VIOLATION:**
```typescript
// ❌ WRONG: Different context types for same purpose
// Plugin A
function logError(context: Record<string, any>) { ... }

// Plugin B
function logError(context: { [key: string]: unknown }) { ... }

// Plugin C
function logError(context: ErrorContextData) { ... }
```

**CORRECTION:**
```typescript
// ✅ CORRECT: Unified context type system
// interfaces/context.ts
export interface BaseContextData {
    executionId?: string;
    sessionId?: string;
    userId?: string;
    [key: string]: string | number | boolean | Date | undefined;
}

export interface ErrorContextData extends BaseContextData {
    errorType?: string;
    stack?: string;
}

export interface LoggingContextData extends BaseContextData {
    logLevel?: string;
    operation?: string;
}
```

### Rule 3: Metadata Type Standardization
**VIOLATION:**
```typescript
// ❌ WRONG: Inconsistent metadata types
// File A
metadata?: Record<string, any>

// File B  
metadata?: { [key: string]: unknown }

// File C
metadata?: Record<string, string | number | boolean>
```

**CORRECTION:**
```typescript
// ✅ CORRECT: Standardized metadata type
// interfaces/metadata.ts
export type StandardMetadata = Record<string, string | number | boolean | Date | string[]>;

// All files
import type { StandardMetadata } from '../interfaces/metadata';
metadata?: StandardMetadata
```

### Rule 4: Type Import-Only Policy
```typescript
// ✅ CORRECT: Import types, never redeclare
import type { 
    ToolParameters, 
    ToolExecutionResult 
} from '../interfaces/tool';
import type { ErrorContextData } from '../utils/errors';
import type { BaseContextData } from '../interfaces/context';

// ❌ WRONG: Redeclaring existing types
export type ToolParams = Record<string, any>; // Duplicates ToolParameters
export interface MyErrorContext { ... }       // Duplicates ErrorContextData
```

## Detection and Prevention

### 1. Type Duplication Detection
Before creating any new type, search for existing similar types:

```bash
# Search for existing context types
grep -r "interface.*Context" src/
grep -r "type.*Context" src/

# Search for existing metadata types  
grep -r "interface.*Metadata" src/
grep -r "type.*Metadata" src/

# Search for Record<string, any> usages
grep -r "Record<string, any>" src/
```

### 2. Type Compatibility Verification
When types seem incompatible, check if they're actually duplicates:

```typescript
// If you get: Type X is not assignable to Type Y
// 1. Check if X and Y are semantically the same
// 2. If yes, use single type definition
// 3. If no, create proper inheritance hierarchy
```

### 3. Refactoring Pattern
When consolidating duplicate types:

```typescript
// Step 1: Identify the most comprehensive type definition
// Step 2: Move it to appropriate central authority file
// Step 3: Update all imports across codebase
// Step 4: Remove duplicate declarations
// Step 5: Verify no breaking changes
```

## Central Type Authorities by Domain

### Error Handling
- **Owner:** [utils/errors.ts](mdc:packages/agents/src/utils/errors.ts)
- **Types:** `ErrorContextData`, `RobotaError`, all error classes
- **Import pattern:** `import type { ErrorContextData } from '../utils/errors'`

### Tool System  
- **Owner:** [interfaces/tool.ts](mdc:packages/agents/src/interfaces/tool.ts)
- **Types:** `ToolParameters`, `ToolExecutionResult`, `ToolExecutionData`
- **Import pattern:** `import type { ToolParameters } from '../interfaces/tool'`

### Plugin System
- **Owner:** [abstracts/base-plugin.ts](mdc:packages/agents/src/abstracts/base-plugin.ts)
- **Types:** `BaseExecutionContext`, `BaseExecutionResult`, `PluginStats`
- **Import pattern:** `import type { BaseExecutionContext } from '../abstracts/base-plugin'`

### Agent System
- **Owner:** [interfaces/agent.ts](mdc:packages/agents/src/interfaces/agent.ts)  
- **Types:** `AgentConfig`, `UniversalMessage`, `RunOptions`
- **Import pattern:** `import type { AgentConfig } from '../interfaces/agent'`

## Compliance Verification

### Before Adding New Types
1. **Search existing types:** Verify no similar type exists
2. **Check type hierarchy:** Determine correct ownership
3. **Verify import paths:** Ensure proper dependency direction
4. **Test compatibility:** Verify no breaking changes

### Type Naming Consistency
- Use semantic naming: `[Domain][Purpose][Context]`
- Context data: `*ContextData` (e.g., `LoggingContextData`)
- Metadata: `*Metadata` (e.g., `ExecutionMetadata`)
- Statistics: `*Stats` or `*Statistics` (e.g., `PluginStats`)
- Options/Config: `*Options` or `*Config` (e.g., `AgentConfig`)

### Violation Penalties
- **Type duplication:** Must consolidate into single authority
- **Import violations:** Must use proper import-only pattern
- **Inconsistent naming:** Must follow semantic naming rules
- **Context type mixing:** Must use unified context type system

This rule ensures type safety, maintainability, and prevents the TypeScript compatibility issues we've been encountering.

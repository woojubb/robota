---
description:
globs:
alwaysApply: false
---
# TypeScript Semantic Type Naming Standards

## Core Principle

모든 재사용 가능한 타입은 **용도(Purpose) + 스코프(Scope) + 기능(Function)**을 타입명에 명시해야 합니다.

## Naming Convention Pattern

```typescript
export type [Scope][Purpose][Context] = ...
export interface [Scope][Purpose][Options|Data|Config|Metadata] { ... }
```

### Pattern Examples

#### ✅ Good Examples
```typescript
// Scope: Service, Purpose: Tool execution, Context: Parameters
export type ServiceToolExecutionParameters = Record<string, string | number | boolean | string[]>;

// Scope: Agent, Purpose: Creation, Context: Metadata
export type AgentCreationMetadata = Record<string, string | number | boolean | Date>;

// Scope: Conversation, Purpose: Context, Context: Metadata
export type ConversationContextMetadata = Record<string, string | number | boolean | Date>;

// Scope: Provider, Purpose: Configuration, Context: Value
export type ProviderConfigValue = string | number | boolean;
```

#### ❌ Bad Examples
```typescript
// Too generic - doesn't indicate scope or purpose
export type Metadata = Record<string, any>;

// Too vague - what kind of parameters?
export type Parameters = Record<string, unknown>;

// Missing context - config for what?
export type ConfigData = Record<string, string>;
```

## Scope Categories

### 1. **Layer Scopes** (아키텍처 계층)
- `Service`: Service layer types
- `Manager`: Manager layer types  
- `Provider`: Provider layer types
- `Agent`: Agent layer types
- `Plugin`: Plugin layer types

### 2. **Domain Scopes** (도메인 영역)
- `Conversation`: 대화 관련
- `Tool`: 도구 실행 관련
- `Execution`: 실행 관련
- `Authentication`: 인증 관련
- `Performance`: 성능 관련

### 3. **Component Scopes** (컴포넌트)
- `Webhook`: 웹훅 관련
- `Analytics`: 분석 관련
- `Logging`: 로깅 관련
- `Usage`: 사용량 관련

## Purpose Categories

### 1. **Data Types**
- `Metadata`: 메타데이터 저장
- `Parameters`: 파라미터 전달
- `Config`: 설정 정보
- `Options`: 옵션 설정
- `Response`: 응답 데이터
- `Request`: 요청 데이터

### 2. **Operational Types**
- `Execution`: 실행 관련
- `Validation`: 검증 관련
- `Creation`: 생성 관련
- `Processing`: 처리 관련

## Context Suffixes

### Common Suffixes
- `Data`: 데이터 구조체
- `Options`: 선택적 설정
- `Config`: 필수 설정
- `Metadata`: 부가 정보
- `Parameters`: 매개변수
- `Value`: 값 타입
- `Result`: 결과 타입

## Type Reusability Rules

### 1. **Single Responsibility**
각 타입은 하나의 명확한 목적만 가져야 함
```typescript
// ✅ Good - specific purpose
export type ConversationContextMetadata = Record<string, string | number | boolean | Date>;

// ❌ Bad - multiple purposes mixed
export type GeneralData = Record<string, any>;
```

### 2. **Scope Isolation**
다른 스코프에서는 동일한 목적이라도 별도 타입 사용
```typescript
// ✅ Good - scope-specific types
export type ServiceExecutionMetadata = Record<string, string | number | boolean | Date>;
export type PluginExecutionMetadata = Record<string, string | number | boolean | Date>;

// ❌ Bad - shared generic type
export type ExecutionMetadata = Record<string, any>;
```

### 3. **Progressive Specificity**
기본 타입 → 도메인 타입 → 컴포넌트 타입 순으로 구체화
```typescript
// Base type
export type MetadataValue = string | number | boolean | Date;

// Domain-specific type  
export type ConversationMetadata = Record<string, MetadataValue>;

// Component-specific type
export type ChatInstanceMetadata = ConversationMetadata & {
  sessionId: string;
  userId: string;
};
```

## Prohibited Patterns

### ❌ Forbidden Type Names
```typescript
// Generic names without context
type Data = any;
type Config = any;
type Options = any;
type Params = any;
type Result = any;

// Any/unknown without specific reason
type AnyData = Record<string, any>;
type UnknownValue = unknown;
```

### ❌ Forbidden Type Structures
```typescript
// Using any/unknown without justification
interface SomeInterface {
  data: any; // ❌ Should be specific type
  metadata: Record<string, unknown>; // ❌ Should be scoped metadata type
}
```

## Implementation Guidelines

### 1. **Type Definition Location**
타입은 해당 스코프의 interfaces 파일에서 정의
```
src/interfaces/
├── service.ts    # Service* types
├── manager.ts    # Manager* types  
├── provider.ts   # Provider* types
└── agent.ts      # Agent* types
```

### 2. **Import Strategy**
```typescript
// ✅ Good - specific imports
import type { ServiceToolExecutionParameters, ConversationContextMetadata } from './service';

// ❌ Bad - generic imports
import type { Parameters, Metadata } from './types';
```

### 3. **Export Strategy**
모든 재사용 타입은 명시적으로 export
```typescript
// ✅ Good
export type AgentCreationMetadata = Record<string, string | number | boolean | Date>;
export type ServiceToolExecutionParameters = Record<string, string | number | boolean | string[]>;

// ❌ Bad - inline types
function createAgent(metadata: Record<string, any>) { ... }
```

## Migration Strategy

기존 코드를 점진적으로 마이그레이션:

1. **Phase 1**: any/unknown 타입을 임시 구체적 타입으로 변경
2. **Phase 2**: 반복 패턴 식별 및 semantic 타입명 생성  
3. **Phase 3**: 전체 codebase에 semantic 타입 적용
4. **Phase 4**: Lint rule로 semantic naming 강제

## Validation Rules

### ESLint Integration
```json
{
  "@typescript-eslint/no-explicit-any": "error",
  "@typescript-eslint/ban-types": {
    "types": {
      "unknown": "Use specific scoped type instead"
    }
  }
}
```

이 가이드라인을 통해 타입 시스템의 가독성과 유지보수성을 크게 향상시킬 수 있습니다.

---
description: 
globs: 
alwaysApply: false
---
# Robota Agents Type System Rules

## Type Ownership Architecture

### Central Type Authorities
1. **[interfaces/tool.ts](mdc:packages/agents/src/interfaces/tool.ts)** - Single source of truth for:
   - `ToolParameters`, `ToolExecutionResult`, `ToolExecutionData`
   - All tool-related interfaces and types

2. **[interfaces/agent.ts](mdc:packages/agents/src/interfaces/agent.ts)** - Message and agent types:
   - `UniversalMessage`, `AgentConfig`, `RunOptions`
   - Agent lifecycle and configuration types

3. **Plugin-specific files** - Each plugin owns specialized types:
   - `WebhookPluginStats`, `ExecutionAnalyticsStats`, etc.
   - Plugin-specific context and configuration types

### Import-Only Rule (Strictly Enforced)
```typescript
// ✅ CORRECT: Import from type owner
import type { ToolParameters, ToolExecutionResult } from '../interfaces/tool';

// ❌ FORBIDDEN: Duplicate type definitions
type ToolParameters = Record<string, unknown>; // VIOLATION
```

## Systematic Type Fix Approach

### Pattern 1: exactOptionalPropertyTypes Compatibility
**Issue**: TypeScript's exactOptionalPropertyTypes conflicts with `undefined` in union types

```typescript
// ❌ PROBLEMATIC: Extends with undefined
interface MyContext extends Record<string, string | undefined> {}

// ✅ SOLUTION: Use exact optional properties
interface MyContext {
  executionId?: string;
  sessionId?: string;
  // TypeScript handles undefined automatically with ?
}
```

### Pattern 2: BasePlugin Method Signature Alignment
**Issue**: Plugin methods not matching BasePlugin abstract signatures

```typescript
// ✅ CORRECT: Match BasePlugin exactly
override async onError(error: Error, context?: ErrorContext): Promise<void> {
  // Use ErrorContext from BasePlugin, not Record<string, unknown>
}

override async afterToolCall(
  toolName: string, 
  parameters: ToolParameters, 
  result: ToolExecutionResult
): Promise<void> {
  // Use exact types from interfaces/tool.ts
}
```

### Pattern 3: Provider Interface Unification
**Issue**: Different provider types causing compatibility problems

```typescript
// Import unified types from central authority
import type { UniversalMessage } from '../managers/conversation-history-manager';
import type { BaseAIProvider } from '../abstracts/base-ai-provider';
```

## Exception Documentation Requirements

### Required Format for any/unknown Usage
```typescript
// REASON: [Specific technical reason why NO alternative is possible]
// ALTERNATIVES_CONSIDERED: Union types (reason), interface definition (reason), generic types (reason), conditional types (reason), mapped types (reason), type guards (reason), custom declarations (reason), code refactoring (reason), @types packages (reason), external library integration (reason), utility types (reason), intersection types (reason)
// TODO: [Mandatory specific plan to eliminate any/unknown in future]
const data: unknown = externalApiCall();
```

### Valid Exception Cases
1. **External Protocol Integration**: MCP, OpenAPI without TypeScript definitions
2. **Legacy Third-Party Libraries**: No @types packages available
3. **Dynamic JSON Parsing**: Genuinely unknown external API structures

## Type Fix Implementation Strategy

### Step 1: Identify Issue Category
- exactOptionalPropertyTypes compatibility
- BasePlugin method signature mismatch  
- Type ownership violation
- Missing/incorrect imports
- External library integration

### Step 2: Apply Appropriate Pattern
- Use established patterns from this rule
- Reference successful fixes in completed files
- Maintain consistency with type ownership system

### Step 3: Iterate Without Limit
- **No 3-attempt restriction**
- Continue until type safety achieved
- Seek architectural changes if needed
- Document complex cases properly

### Step 4: Validate and Test
```bash
# Verify ESLint improvements
pnpm lint | grep -E "@typescript-eslint/(ban-types|no-explicit-any)" | wc -l

# Ensure build success
pnpm build

# Run tests
pnpm test
```

## Reference Examples

### MCP Tool (Documented Exception)
[mcp-tool.ts](mdc:packages/agents/src/tools/implementations/mcp-tool.ts) - Properly documented MCP protocol dynamic content with full 12-alternative analysis

### Webhook Plugin (Concrete Types)
[webhook-plugin.ts](mdc:packages/agents/src/plugins/webhook-plugin.ts) - Replaced any types with WebhookEventData

### BasePlugin Standardization
[base-plugin.ts](mdc:packages/agents/src/abstracts/base-plugin.ts) - Eliminated `[key: string]: unknown` with concrete interfaces

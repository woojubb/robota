# Base Class Common Functionality Handling

## Core Principle
**Handle common functionality in base classes to prevent code duplication in derived classes.**

## Plugin Architecture Rules

### 1. BasePlugin Common Properties
- All common properties like `enabled` should have **default values in the base class**
- **Base class default**: `public enabled = true;`
- **Derived classes**: Should NOT duplicate enabled handling unless they need custom logic

### 2. Plugin Options Pattern
```typescript
// ✅ CORRECT: BasePluginOptions with optional enabled
export interface BasePluginOptions {
    enabled?: boolean; // Optional with default in base class
}

// ✅ CORRECT: Derived plugin options extend base
export interface LoggingPluginOptions extends BasePluginOptions {
    strategy: LoggingStrategy;
    level?: LogLevel;
    // ... specific options
}

// ✅ CORRECT: Derived plugin constructor - NO enabled duplication
constructor(options: LoggingPluginOptions) {
    super();
    this.pluginOptions = {
        enabled: options.enabled ?? true, // Keep in pluginOptions for Required<> type
        strategy: options.strategy,
        // ... other options
    };
    // ❌ DO NOT: this.enabled = options.enabled ?? true; // Base class handles this
}
```

### 3. Type System Design
- Use **BasePluginOptions** as constraint: `BasePlugin<TOptions extends BasePluginOptions>`
- This ensures all plugin options have optional `enabled` property
- **AgentConfig** uses: `plugins?: Array<BasePlugin<BasePluginOptions, PluginStats>>;`

### 4. Anti-Patterns to Avoid
```typescript
// ❌ WRONG: Duplicating enabled handling in every plugin
class MyPlugin extends BasePlugin {
    constructor(options) {
        super();
        this.enabled = options.enabled ?? true; // ❌ Duplication
    }
}

// ❌ WRONG: Using any/unknown types
plugins?: Array<BasePlugin<any, any>>; // ❌ Type safety violation

// ❌ WRONG: Each plugin having different enabled patterns
```

### 5. Implementation Strategy
1. **Base class** provides default behavior and values
2. **Derived classes** only override when they need custom logic
3. **Plugin options** include the property for type completeness but rely on base class defaults
4. **Type constraints** ensure compatibility without sacrificing type safety

## File References
- Base implementation: [packages/agents/src/abstracts/base-plugin.ts](mdc:packages/agents/src/abstracts/base-plugin.ts)
- Agent configuration: [packages/agents/src/interfaces/agent.ts](mdc:packages/agents/src/interfaces/agent.ts)
- Example plugin: [packages/agents/src/plugins/logging/logging-plugin.ts](mdc:packages/agents/src/plugins/logging/logging-plugin.ts)

## Benefits
- **Reduces code duplication** across all plugins
- **Centralizes common logic** in base class
- **Maintains type safety** without using any/unknown
- **Easier maintenance** - change once in base class, affects all plugins
- **Consistent behavior** across all plugin implementations
description:
globs:
alwaysApply: false
---
